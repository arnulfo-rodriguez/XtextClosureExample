/*
 * generated by Xtext
 */
package org.arz.generator

import java.util.ArrayList
import java.util.LinkedList
import java.util.List
import org.arz.miniScript.Apply
import org.arz.miniScript.BinaryLogicalOperator
import org.arz.miniScript.ComparisonExpression
import org.arz.miniScript.ComparisonOperator
import org.arz.miniScript.Expression
import org.arz.miniScript.Factor
import org.arz.miniScript.FunctionDeclaration
import org.arz.miniScript.LetExpression
import org.arz.miniScript.LiteralBoolean
import org.arz.miniScript.LiteralNumber
import org.arz.miniScript.LogicalBinaryExpression
import org.arz.miniScript.LogicalUnaryExpression
import org.arz.miniScript.NumericExpression
import org.arz.miniScript.Program
import org.arz.miniScript.SymbolReference
import org.arz.miniScript.TernaryExpression
import org.arz.miniScript.TernaryOperator
import org.arz.miniScript.UnaryLogicalOperator
import org.arz.miniScript.VariableAssignment
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

class MiniScriptGenerator implements IGenerator {
	
	private String numericType="Double"
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		var name = resource.URI.segments.last.replace("." + resource.URI.fileExtension,"")
		fsa.generateFile(name + ".java",doCompileProgram(resource.allContents.filter(typeof(Program)).head,name))
	}
	
	
    def String doCompileProgram(Program program,String name) { 
    	'''class «name»
    	{
    		public Object eval()
    		{
    			org.arz.runtime.Context context = new org.arz.runtime.Context();
    			«doCompileStatementSequence(program.expressions)»
    		}
    	}'''
    }
    
	def String doCompileStatementSequence(List<Expression> l) { 
		var rerversedList =  new ArrayList(l.map[exp | doCompileExpression(exp)]).reverse
		var newList = new LinkedList<String>();
		newList.add(("return " + rerversedList.head));
		newList.addAll(rerversedList.tail);
		return newList.reverse.map[str | str + ";"].join("\n")
	}


	
def String doCompileExpression(Expression e)
{
	return switch(e)
	{
 		FunctionDeclaration  :  doCompileFunctionDeclaration(e)
 		VariableAssignment :  doCompileVariableAssignment(e)
	    LogicalBinaryExpression :  doCompileLogicalBinaryExpression(e)
		LogicalUnaryExpression :  doCompileLogicalUnaryExpression (e)
		TernaryExpression :  doCompileTernaryExpression (e)
		ComparisonExpression:  doCompileComparisonExpression(e)
		NumericExpression:  doCompileNumericExpression(e)
		LiteralNumber:  doCompileLiteralNumber(e)
		LiteralBoolean:  doCompileLiteralBoolean(e)
		Apply:  doCompileApply(e)
		SymbolReference:  doCompileSymbolReference(e)
		Factor:  doCompileFactor(e)
		LetExpression:  doCompileLetExpression(e)
		default: ""
    }
}
	def String doCompileLetExpression(LetExpression LetExpression) { 
	   '''new org.arz.runtime.Closure(context.getCurrentEnvironment())
	   {
			«doCompileExecuteBody(newArrayList(),newArrayList(LetExpression.assigment,LetExpression.expression))»
	   }.apply()'''
	}


def String doCompileSymbolReference(SymbolReference symbolReference){
	'''context.get("«symbolReference.id»")'''
}

def String doCompileApply(Apply apply){
	'''«cast("org.arz.runtime.Closure",doCompileExpression(apply.functor))».apply(«apply.arguments.map[arg | doCompileExpression(arg)].join(",")»)'''
}

def String doCompileLiteralNumber(LiteralNumber literalNumber){
	'''new «numericType»(«literalNumber.value.toString()»)'''
}

def String doCompileLiteralBoolean(LiteralBoolean literalBoolean){
	'''new Boolean(«literalBoolean.value.literal»)'''
}

def String doCompileFactor(Factor factor){
		'''«cast(numericType,doCompileExpression(factor.leftTerm))» «factor.operator.literal» «cast(numericType,doCompileExpression(factor.rightTerm))»'''
}
	
def String doCompileNumericExpression(NumericExpression numericExpression){
	'''«cast(numericType,doCompileExpression(numericExpression.leftFactor))» «numericExpression.operator.literal» «cast(numericType,doCompileExpression(numericExpression.rightFactor))»'''
}
	
	
def String doCompileFunctionDeclaration  (FunctionDeclaration   functionDeclaration  ){
	'''new org.arz.runtime.Closure(context.getCurrentEnvironment())
	{
			«doCompileExecuteBody(functionDeclaration.parameters,functionDeclaration.body.expressions)»
	}'''
}

def doCompileExecuteBody(List<String> parameters, List<Expression> expressions) { 
	'''@Override protected Object executeBody(Object[] arguments) {
		«doCompileSetupArguments(parameters)»
		«doCompileStatementSequence(expressions)»
	}
	'''
}


def String doCompileSetupArguments(List<String> list) {
	if (list.size > 0)
	{
	(0..list.size()-1).map[i | '''context.set("«list.get(i)»",arguments[«i»]);'''].join("\n")
    } else {
    	""
    }
} 


def String doCompileVariableAssignment (VariableAssignment  variableAssignment ){
	'''context.set("«variableAssignment.id»",«doCompileExpression(variableAssignment.expression)»)'''
}

def String doCompileLogicalBinaryExpression (LogicalBinaryExpression  logicalBinaryExpression ){
	'''«cast("Boolean",doCompileExpression(logicalBinaryExpression.leftExpr))» «getJavaLogicalOperator(logicalBinaryExpression.operator)» «cast("Boolean",doCompileExpression(logicalBinaryExpression.rightExpr))»'''
}


def String doCompileLogicalUnaryExpression (LogicalUnaryExpression  logicalUnaryExpression ){
	'''(!«cast("Boolean",doCompileExpression(logicalUnaryExpression.expression))»)'''
}

def String doCompileTernaryExpression (TernaryExpression  ternaryExpression ){
	switch(ternaryExpression.operator)
	{
		case TernaryOperator::IF_EXPRESSION : compileIf(ternaryExpression)
	}
}
	
	def String compileIf(TernaryExpression expression) { 
		'''«cast("Boolean",doCompileExpression(expression.firstExpression))» ? 
		(«doCompileExpression(expression.secondExpression)»):
		(«doCompileExpression(expression.thirdExpression)»)'''
	}


def String doCompileComparisonExpression(ComparisonExpression comparisonExpression){
	if (isEqualityExpression(comparisonExpression))
	{
		doCompileEquality(comparisonExpression)
	}else{
		doCompileInequality(comparisonExpression)
	}
}
	def String doCompileInequality(ComparisonExpression expression) { 
		'''«cast(numericType,doCompileExpression(expression.leftExpr))» «expression.operator.literal» «cast(numericType,doCompileExpression(expression.rightExpr))»'''
	}

	def String doCompileEquality(ComparisonExpression expression) { 
		var result = '''(«doCompileExpression(expression.leftExpr)»).equals(«doCompileExpression(expression.rightExpr)»)'''
		if (expression.operator == ComparisonOperator::NOTEQ)
		{
			result = '''(!«result»)'''
		}
		return result.toString()
	}


def boolean isEqualityExpression(ComparisonExpression expression) { 
	return expression.operator == ComparisonOperator::EQ || expression.operator == ComparisonOperator::NOTEQ
}


def String cast(String type,String expression) {
	'''((«type»)(«expression»))'''
}

	def getJavaLogicalOperator(BinaryLogicalOperator operator) { 
		switch operator
		{
			case BinaryLogicalOperator::AND: "&&"
			case BinaryLogicalOperator::OR: "||"
		}
	}
	
	def getJavaLogicalOperator(UnaryLogicalOperator operator) { 
		switch operator
		{
			case UnaryLogicalOperator::NOT: "!"
		}
		
	}

}
