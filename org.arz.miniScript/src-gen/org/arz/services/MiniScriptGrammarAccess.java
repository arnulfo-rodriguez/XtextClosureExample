/*
* generated by Xtext
*/

package org.arz.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MiniScriptGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final RuleCall cProgramParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Model:
		//	Program;
		public ParserRule getRule() { return rule; }

		//Program
		public RuleCall getProgramParserRuleCall() { return cProgramParserRuleCall; }
	}

	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//Program:
		//	expressions+=Expression ";" (expressions+=Expression ";")*;
		public ParserRule getRule() { return rule; }

		//expressions+=Expression ";" (expressions+=Expression ";")*
		public Group getGroup() { return cGroup; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }

		//(expressions+=Expression ";")*
		public Group getGroup_2() { return cGroup_2; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_2_0_0() { return cExpressionsExpressionParserRuleCall_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLogicalBinaryExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLogicalUnaryExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTernaryExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cComparisonExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLetExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//Expression:
		//	FunctionDeclaration | VariableAssignment | LogicalBinaryExpression | LogicalUnaryExpression | TernaryExpression |
		//	ComparisonExpression | LetExpression;
		public ParserRule getRule() { return rule; }

		//FunctionDeclaration | VariableAssignment | LogicalBinaryExpression | LogicalUnaryExpression | TernaryExpression |
		//ComparisonExpression | LetExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionDeclaration
		public RuleCall getFunctionDeclarationParserRuleCall_0() { return cFunctionDeclarationParserRuleCall_0; }

		//VariableAssignment
		public RuleCall getVariableAssignmentParserRuleCall_1() { return cVariableAssignmentParserRuleCall_1; }

		//LogicalBinaryExpression
		public RuleCall getLogicalBinaryExpressionParserRuleCall_2() { return cLogicalBinaryExpressionParserRuleCall_2; }

		//LogicalUnaryExpression
		public RuleCall getLogicalUnaryExpressionParserRuleCall_3() { return cLogicalUnaryExpressionParserRuleCall_3; }

		//TernaryExpression
		public RuleCall getTernaryExpressionParserRuleCall_4() { return cTernaryExpressionParserRuleCall_4; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_5() { return cComparisonExpressionParserRuleCall_5; }

		//LetExpression
		public RuleCall getLetExpressionParserRuleCall_6() { return cLetExpressionParserRuleCall_6; }
	}

	public class LetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cAssigmentAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAssigmentVariableAssignmentParserRuleCall_1_0_0 = (RuleCall)cAssigmentAssignment_1_0.eContents().get(0);
		private final Keyword cCommaKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//LetExpression:
		//	"let" (assigment=VariableAssignment ",") expression=Expression;
		public ParserRule getRule() { return rule; }

		//"let" (assigment=VariableAssignment ",") expression=Expression
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//assigment=VariableAssignment ","
		public Group getGroup_1() { return cGroup_1; }

		//assigment=VariableAssignment
		public Assignment getAssigmentAssignment_1_0() { return cAssigmentAssignment_1_0; }

		//VariableAssignment
		public RuleCall getAssigmentVariableAssignmentParserRuleCall_1_0_0() { return cAssigmentVariableAssignmentParserRuleCall_1_0_0; }

		//","
		public Keyword getCommaKeyword_1_1() { return cCommaKeyword_1_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}

	public class TernaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TernaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorTernaryOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFirstExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFirstExpressionExpressionParserRuleCall_2_0 = (RuleCall)cFirstExpressionAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSecondExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSecondExpressionExpressionParserRuleCall_4_0 = (RuleCall)cSecondExpressionAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cThirdExpressionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cThirdExpressionExpressionParserRuleCall_6_0 = (RuleCall)cThirdExpressionAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//TernaryExpression:
		//	operator=TernaryOperator "(" firstExpression=Expression "," secondExpression=Expression "," thirdExpression=Expression
		//	")";
		public ParserRule getRule() { return rule; }

		//operator=TernaryOperator "(" firstExpression=Expression "," secondExpression=Expression "," thirdExpression=Expression
		//")"
		public Group getGroup() { return cGroup; }

		//operator=TernaryOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//TernaryOperator
		public RuleCall getOperatorTernaryOperatorEnumRuleCall_0_0() { return cOperatorTernaryOperatorEnumRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//firstExpression=Expression
		public Assignment getFirstExpressionAssignment_2() { return cFirstExpressionAssignment_2; }

		//Expression
		public RuleCall getFirstExpressionExpressionParserRuleCall_2_0() { return cFirstExpressionExpressionParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//secondExpression=Expression
		public Assignment getSecondExpressionAssignment_4() { return cSecondExpressionAssignment_4; }

		//Expression
		public RuleCall getSecondExpressionExpressionParserRuleCall_4_0() { return cSecondExpressionExpressionParserRuleCall_4_0; }

		//","
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }

		//thirdExpression=Expression
		public Assignment getThirdExpressionAssignment_6() { return cThirdExpressionAssignment_6; }

		//Expression
		public RuleCall getThirdExpressionExpressionParserRuleCall_6_0() { return cThirdExpressionExpressionParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}

	public class LogicalBinaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalBinaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorBinaryLogicalOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLeftExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLeftExprExpressionParserRuleCall_2_0 = (RuleCall)cLeftExprAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRightExprAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRightExprExpressionParserRuleCall_4_0 = (RuleCall)cRightExprAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LogicalBinaryExpression:
		//	operator=BinaryLogicalOperator "(" leftExpr=Expression "," rightExpr=Expression ")";
		public ParserRule getRule() { return rule; }

		//operator=BinaryLogicalOperator "(" leftExpr=Expression "," rightExpr=Expression ")"
		public Group getGroup() { return cGroup; }

		//operator=BinaryLogicalOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//BinaryLogicalOperator
		public RuleCall getOperatorBinaryLogicalOperatorEnumRuleCall_0_0() { return cOperatorBinaryLogicalOperatorEnumRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//leftExpr=Expression
		public Assignment getLeftExprAssignment_2() { return cLeftExprAssignment_2; }

		//Expression
		public RuleCall getLeftExprExpressionParserRuleCall_2_0() { return cLeftExprExpressionParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//rightExpr=Expression
		public Assignment getRightExprAssignment_4() { return cRightExprAssignment_4; }

		//Expression
		public RuleCall getRightExprExpressionParserRuleCall_4_0() { return cRightExprExpressionParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class LogicalUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalUnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorUnaryLogicalOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LogicalUnaryExpression:
		//	operator=UnaryLogicalOperator "(" expression=Expression ")";
		public ParserRule getRule() { return rule; }

		//operator=UnaryLogicalOperator "(" expression=Expression ")"
		public Group getGroup() { return cGroup; }

		//operator=UnaryLogicalOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//UnaryLogicalOperator
		public RuleCall getOperatorUnaryLogicalOperatorEnumRuleCall_0_0() { return cOperatorUnaryLogicalOperatorEnumRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNumericExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorComparisonOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprNumericExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//ComparisonExpression returns Expression:
		//	NumericExpression ({ComparisonExpression.leftExpr=current} operator=ComparisonOperator rightExpr=NumericExpression)?;
		public ParserRule getRule() { return rule; }

		//NumericExpression ({ComparisonExpression.leftExpr=current} operator=ComparisonOperator rightExpr=NumericExpression)?
		public Group getGroup() { return cGroup; }

		//NumericExpression
		public RuleCall getNumericExpressionParserRuleCall_0() { return cNumericExpressionParserRuleCall_0; }

		//({ComparisonExpression.leftExpr=current} operator=ComparisonOperator rightExpr=NumericExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ComparisonExpression.leftExpr=current}
		public Action getComparisonExpressionLeftExprAction_1_0() { return cComparisonExpressionLeftExprAction_1_0; }

		//operator=ComparisonOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ComparisonOperator
		public RuleCall getOperatorComparisonOperatorEnumRuleCall_1_1_0() { return cOperatorComparisonOperatorEnumRuleCall_1_1_0; }

		//rightExpr=NumericExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//NumericExpression
		public RuleCall getRightExprNumericExpressionParserRuleCall_1_2_0() { return cRightExprNumericExpressionParserRuleCall_1_2_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFuncKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParametersIDTerminalRuleCall_2_0_0 = (RuleCall)cParametersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersIDTerminalRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//FunctionDeclaration:
		//	"func" "(" (parameters+=ID ("," parameters+=ID)*)? ")" body=Body;
		public ParserRule getRule() { return rule; }

		//"func" "(" (parameters+=ID ("," parameters+=ID)*)? ")" body=Body
		public Group getGroup() { return cGroup; }

		//"func"
		public Keyword getFuncKeyword_0() { return cFuncKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(parameters+=ID ("," parameters+=ID)*)?
		public Group getGroup_2() { return cGroup_2; }

		//parameters+=ID
		public Assignment getParametersAssignment_2_0() { return cParametersAssignment_2_0; }

		//ID
		public RuleCall getParametersIDTerminalRuleCall_2_0_0() { return cParametersIDTerminalRuleCall_2_0_0; }

		//("," parameters+=ID)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//parameters+=ID
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }

		//ID
		public RuleCall getParametersIDTerminalRuleCall_2_1_1_0() { return cParametersIDTerminalRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=Body
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//Body
		public RuleCall getBodyBodyParserRuleCall_4_0() { return cBodyBodyParserRuleCall_4_0; }
	}

	public class BodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Body");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBodyAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cExpressionsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_2_0_0 = (RuleCall)cExpressionsAssignment_1_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Body:
		//	expressions+=Expression | {Body} "{" (expressions+=Expression ";")* "}";
		public ParserRule getRule() { return rule; }

		//expressions+=Expression | {Body} "{" (expressions+=Expression ";")* "}"
		public Alternatives getAlternatives() { return cAlternatives; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_0_0() { return cExpressionsExpressionParserRuleCall_0_0; }

		//{Body} "{" (expressions+=Expression ";")* "}"
		public Group getGroup_1() { return cGroup_1; }

		//{Body}
		public Action getBodyAction_1_0() { return cBodyAction_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }

		//(expressions+=Expression ";")*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_2_0() { return cExpressionsAssignment_1_2_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_2_0_0() { return cExpressionsExpressionParserRuleCall_1_2_0_0; }

		//";"
		public Keyword getSemicolonKeyword_1_2_1() { return cSemicolonKeyword_1_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }
	}

	public class SymbolReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SymbolReference");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//SymbolReference:
		//	id=ID;
		public ParserRule getRule() { return rule; }

		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}

	public class NumericExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFactorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNumericExpressionLeftFactorAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditionOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightFactorAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFactorFactorParserRuleCall_1_2_0 = (RuleCall)cRightFactorAssignment_1_2.eContents().get(0);
		
		//NumericExpression returns Expression:
		//	Factor ({NumericExpression.leftFactor=current} operator=AdditionOperator rightFactor=Factor)*;
		public ParserRule getRule() { return rule; }

		//Factor ({NumericExpression.leftFactor=current} operator=AdditionOperator rightFactor=Factor)*
		public Group getGroup() { return cGroup; }

		//Factor
		public RuleCall getFactorParserRuleCall_0() { return cFactorParserRuleCall_0; }

		//({NumericExpression.leftFactor=current} operator=AdditionOperator rightFactor=Factor)*
		public Group getGroup_1() { return cGroup_1; }

		//{NumericExpression.leftFactor=current}
		public Action getNumericExpressionLeftFactorAction_1_0() { return cNumericExpressionLeftFactorAction_1_0; }

		//operator=AdditionOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditionOperator
		public RuleCall getOperatorAdditionOperatorEnumRuleCall_1_1_0() { return cOperatorAdditionOperatorEnumRuleCall_1_1_0; }

		//rightFactor=Factor
		public Assignment getRightFactorAssignment_1_2() { return cRightFactorAssignment_1_2; }

		//Factor
		public RuleCall getRightFactorFactorParserRuleCall_1_2_0() { return cRightFactorFactorParserRuleCall_1_2_0; }
	}

	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Factor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTermParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFactorLeftTermAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorFactorOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightTermAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightTermTermParserRuleCall_1_2_0 = (RuleCall)cRightTermAssignment_1_2.eContents().get(0);
		
		//Factor returns Expression:
		//	Term ({Factor.leftTerm=current} operator=FactorOperator rightTerm=Term)*;
		public ParserRule getRule() { return rule; }

		//Term ({Factor.leftTerm=current} operator=FactorOperator rightTerm=Term)*
		public Group getGroup() { return cGroup; }

		//Term
		public RuleCall getTermParserRuleCall_0() { return cTermParserRuleCall_0; }

		//({Factor.leftTerm=current} operator=FactorOperator rightTerm=Term)*
		public Group getGroup_1() { return cGroup_1; }

		//{Factor.leftTerm=current}
		public Action getFactorLeftTermAction_1_0() { return cFactorLeftTermAction_1_0; }

		//operator=FactorOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//FactorOperator
		public RuleCall getOperatorFactorOperatorEnumRuleCall_1_1_0() { return cOperatorFactorOperatorEnumRuleCall_1_1_0; }

		//rightTerm=Term
		public Assignment getRightTermAssignment_1_2() { return cRightTermAssignment_1_2; }

		//Term
		public RuleCall getRightTermTermParserRuleCall_1_2_0() { return cRightTermTermParserRuleCall_1_2_0; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cApplyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Term returns Expression:
		//	LiteralExpression | Apply;
		public ParserRule getRule() { return rule; }

		//LiteralExpression | Apply
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_0() { return cLiteralExpressionParserRuleCall_0; }

		//Apply
		public RuleCall getApplyParserRuleCall_1() { return cApplyParserRuleCall_1; }
	}

	public class ApplyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Apply");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cApplyFunctorAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cArgumentsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cArgumentsExpressionParserRuleCall_1_2_0_0 = (RuleCall)cArgumentsAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cArgumentsExpressionParserRuleCall_1_2_1_1_0 = (RuleCall)cArgumentsAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Apply returns Expression:
		//	Functor ({Apply.functor=current} "(" (arguments+=Expression ("," arguments+=Expression)*)? ")")*;
		public ParserRule getRule() { return rule; }

		//Functor ({Apply.functor=current} "(" (arguments+=Expression ("," arguments+=Expression)*)? ")")*
		public Group getGroup() { return cGroup; }

		//Functor
		public RuleCall getFunctorParserRuleCall_0() { return cFunctorParserRuleCall_0; }

		//({Apply.functor=current} "(" (arguments+=Expression ("," arguments+=Expression)*)? ")")*
		public Group getGroup_1() { return cGroup_1; }

		//{Apply.functor=current}
		public Action getApplyFunctorAction_1_0() { return cApplyFunctorAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//(arguments+=Expression ("," arguments+=Expression)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//arguments+=Expression
		public Assignment getArgumentsAssignment_1_2_0() { return cArgumentsAssignment_1_2_0; }

		//Expression
		public RuleCall getArgumentsExpressionParserRuleCall_1_2_0_0() { return cArgumentsExpressionParserRuleCall_1_2_0_0; }

		//("," arguments+=Expression)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//arguments+=Expression
		public Assignment getArgumentsAssignment_1_2_1_1() { return cArgumentsAssignment_1_2_1_1; }

		//Expression
		public RuleCall getArgumentsExpressionParserRuleCall_1_2_1_1_0() { return cArgumentsExpressionParserRuleCall_1_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class FunctorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Functor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSymbolReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParenthesisExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Functor returns Expression:
		//	SymbolReference | ParenthesisExpression;
		public ParserRule getRule() { return rule; }

		//SymbolReference | ParenthesisExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//SymbolReference
		public RuleCall getSymbolReferenceParserRuleCall_0() { return cSymbolReferenceParserRuleCall_0; }

		//ParenthesisExpression
		public RuleCall getParenthesisExpressionParserRuleCall_1() { return cParenthesisExpressionParserRuleCall_1; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralNumberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralBooleanParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//LiteralExpression returns Expression:
		//	LiteralNumber | LiteralBoolean;
		public ParserRule getRule() { return rule; }

		//LiteralNumber | LiteralBoolean
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralNumber
		public RuleCall getLiteralNumberParserRuleCall_0() { return cLiteralNumberParserRuleCall_0; }

		//LiteralBoolean
		public RuleCall getLiteralBooleanParserRuleCall_1() { return cLiteralBooleanParserRuleCall_1; }
	}

	public class LiteralBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralBoolean");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBooleanValueEnumRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LiteralBoolean:
		//	value=BooleanValue;
		public ParserRule getRule() { return rule; }

		//value=BooleanValue
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BooleanValue
		public RuleCall getValueBooleanValueEnumRuleCall_0() { return cValueBooleanValueEnumRuleCall_0; }
	}

	public class LiteralNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralNumber");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LiteralNumber:
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class VariableAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdIDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//VariableAssignment:
		//	id=ID "=" expression=Expression;
		public ParserRule getRule() { return rule; }

		//id=ID "=" expression=Expression
		public Group getGroup() { return cGroup; }

		//id=ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_0_0() { return cIdIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}

	public class ParenthesisExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesisExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesisExpression returns Expression:
		//	"(" Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	
	
	public class AdditionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAddEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAddPlusSignKeyword_0_0 = (Keyword)cAddEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSubtractEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSubtractHyphenMinusKeyword_1_0 = (Keyword)cSubtractEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditionOperator:
		//	add="+" | subtract="-";
		public EnumRule getRule() { return rule; }

		//add="+" | subtract="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//add="+"
		public EnumLiteralDeclaration getAddEnumLiteralDeclaration_0() { return cAddEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getAddPlusSignKeyword_0_0() { return cAddPlusSignKeyword_0_0; }

		//subtract="-"
		public EnumLiteralDeclaration getSubtractEnumLiteralDeclaration_1() { return cSubtractEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getSubtractHyphenMinusKeyword_1_0() { return cSubtractHyphenMinusKeyword_1_0; }
	}

	public class FactorOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "FactorOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMultEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMultAsteriskKeyword_0_0 = (Keyword)cMultEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDivisionEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDivisionSolidusKeyword_1_0 = (Keyword)cDivisionEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum FactorOperator:
		//	mult="*" | division="/";
		public EnumRule getRule() { return rule; }

		//mult="*" | division="/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//mult="*"
		public EnumLiteralDeclaration getMultEnumLiteralDeclaration_0() { return cMultEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getMultAsteriskKeyword_0_0() { return cMultAsteriskKeyword_0_0; }

		//division="/"
		public EnumLiteralDeclaration getDivisionEnumLiteralDeclaration_1() { return cDivisionEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDivisionSolidusKeyword_1_0() { return cDivisionSolidusKeyword_1_0; }
	}

	public class ComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGtEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGtGreaterThanSignKeyword_0_0 = (Keyword)cGtEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGteEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGteGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGteEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLtEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLtLessThanSignKeyword_2_0 = (Keyword)cLtEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLteEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLteLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLteEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEqEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEqEqualsSignEqualsSignKeyword_4_0 = (Keyword)cEqEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNoteqEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNoteqExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNoteqEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum ComparisonOperator:
		//	gt=">" | gte=">=" | lt="<" | lte="<=" | eq="==" | noteq="!=";
		public EnumRule getRule() { return rule; }

		//gt=">" | gte=">=" | lt="<" | lte="<=" | eq="==" | noteq="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//gt=">"
		public EnumLiteralDeclaration getGtEnumLiteralDeclaration_0() { return cGtEnumLiteralDeclaration_0; }

		//">"
		public Keyword getGtGreaterThanSignKeyword_0_0() { return cGtGreaterThanSignKeyword_0_0; }

		//gte=">="
		public EnumLiteralDeclaration getGteEnumLiteralDeclaration_1() { return cGteEnumLiteralDeclaration_1; }

		//">="
		public Keyword getGteGreaterThanSignEqualsSignKeyword_1_0() { return cGteGreaterThanSignEqualsSignKeyword_1_0; }

		//lt="<"
		public EnumLiteralDeclaration getLtEnumLiteralDeclaration_2() { return cLtEnumLiteralDeclaration_2; }

		//"<"
		public Keyword getLtLessThanSignKeyword_2_0() { return cLtLessThanSignKeyword_2_0; }

		//lte="<="
		public EnumLiteralDeclaration getLteEnumLiteralDeclaration_3() { return cLteEnumLiteralDeclaration_3; }

		//"<="
		public Keyword getLteLessThanSignEqualsSignKeyword_3_0() { return cLteLessThanSignEqualsSignKeyword_3_0; }

		//eq="=="
		public EnumLiteralDeclaration getEqEnumLiteralDeclaration_4() { return cEqEnumLiteralDeclaration_4; }

		//"=="
		public Keyword getEqEqualsSignEqualsSignKeyword_4_0() { return cEqEqualsSignEqualsSignKeyword_4_0; }

		//noteq="!="
		public EnumLiteralDeclaration getNoteqEnumLiteralDeclaration_5() { return cNoteqEnumLiteralDeclaration_5; }

		//"!="
		public Keyword getNoteqExclamationMarkEqualsSignKeyword_5_0() { return cNoteqExclamationMarkEqualsSignKeyword_5_0; }
	}

	public class UnaryLogicalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryLogicalOperator");
		private final EnumLiteralDeclaration cNotEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cNotNotKeyword_0 = (Keyword)cNotEnumLiteralDeclaration.eContents().get(0);
		
		//enum UnaryLogicalOperator:
		//	not;
		public EnumRule getRule() { return rule; }

		//not
		public EnumLiteralDeclaration getNotEnumLiteralDeclaration() { return cNotEnumLiteralDeclaration; }

		//"not"
		public Keyword getNotNotKeyword_0() { return cNotNotKeyword_0; }
	}

	public class BinaryLogicalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BinaryLogicalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAndEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAndAndKeyword_0_0 = (Keyword)cAndEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOrEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOrOrKeyword_1_0 = (Keyword)cOrEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BinaryLogicalOperator:
		//	and | or;
		public EnumRule getRule() { return rule; }

		//and | or
		public Alternatives getAlternatives() { return cAlternatives; }

		//and
		public EnumLiteralDeclaration getAndEnumLiteralDeclaration_0() { return cAndEnumLiteralDeclaration_0; }

		//"and"
		public Keyword getAndAndKeyword_0_0() { return cAndAndKeyword_0_0; }

		//or
		public EnumLiteralDeclaration getOrEnumLiteralDeclaration_1() { return cOrEnumLiteralDeclaration_1; }

		//"or"
		public Keyword getOrOrKeyword_1_0() { return cOrOrKeyword_1_0; }
	}

	public class TernaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "TernaryOperator");
		private final EnumLiteralDeclaration cIfExpressionEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cIfExpressionIfKeyword_0 = (Keyword)cIfExpressionEnumLiteralDeclaration.eContents().get(0);
		
		//enum TernaryOperator:
		//	ifExpression="if";
		public EnumRule getRule() { return rule; }

		//ifExpression="if"
		public EnumLiteralDeclaration getIfExpressionEnumLiteralDeclaration() { return cIfExpressionEnumLiteralDeclaration; }

		//"if"
		public Keyword getIfExpressionIfKeyword_0() { return cIfExpressionIfKeyword_0; }
	}

	public class BooleanValueElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTrueEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTrueTrueKeyword_0_0 = (Keyword)cTrueEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFalseEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFalseFalseKeyword_1_0 = (Keyword)cFalseEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BooleanValue:
		//	true | false;
		public EnumRule getRule() { return rule; }

		//true | false
		public Alternatives getAlternatives() { return cAlternatives; }

		//true
		public EnumLiteralDeclaration getTrueEnumLiteralDeclaration_0() { return cTrueEnumLiteralDeclaration_0; }

		//"true"
		public Keyword getTrueTrueKeyword_0_0() { return cTrueTrueKeyword_0_0; }

		//false
		public EnumLiteralDeclaration getFalseEnumLiteralDeclaration_1() { return cFalseEnumLiteralDeclaration_1; }

		//"false"
		public Keyword getFalseFalseKeyword_1_0() { return cFalseFalseKeyword_1_0; }
	}
	
	private ModelElements pModel;
	private ProgramElements pProgram;
	private AdditionOperatorElements unknownRuleAdditionOperator;
	private FactorOperatorElements unknownRuleFactorOperator;
	private ComparisonOperatorElements unknownRuleComparisonOperator;
	private UnaryLogicalOperatorElements unknownRuleUnaryLogicalOperator;
	private BinaryLogicalOperatorElements unknownRuleBinaryLogicalOperator;
	private TernaryOperatorElements unknownRuleTernaryOperator;
	private BooleanValueElements unknownRuleBooleanValue;
	private ExpressionElements pExpression;
	private LetExpressionElements pLetExpression;
	private TernaryExpressionElements pTernaryExpression;
	private LogicalBinaryExpressionElements pLogicalBinaryExpression;
	private LogicalUnaryExpressionElements pLogicalUnaryExpression;
	private ComparisonExpressionElements pComparisonExpression;
	private FunctionDeclarationElements pFunctionDeclaration;
	private BodyElements pBody;
	private SymbolReferenceElements pSymbolReference;
	private NumericExpressionElements pNumericExpression;
	private FactorElements pFactor;
	private TermElements pTerm;
	private ApplyElements pApply;
	private FunctorElements pFunctor;
	private LiteralExpressionElements pLiteralExpression;
	private LiteralBooleanElements pLiteralBoolean;
	private LiteralNumberElements pLiteralNumber;
	private VariableAssignmentElements pVariableAssignment;
	private ParenthesisExpressionElements pParenthesisExpression;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MiniScriptGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.arz.MiniScript".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	Program;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Program:
	//	expressions+=Expression ";" (expressions+=Expression ";")*;
	public ProgramElements getProgramAccess() {
		return (pProgram != null) ? pProgram : (pProgram = new ProgramElements());
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//enum AdditionOperator:
	//	add="+" | subtract="-";
	public AdditionOperatorElements getAdditionOperatorAccess() {
		return (unknownRuleAdditionOperator != null) ? unknownRuleAdditionOperator : (unknownRuleAdditionOperator = new AdditionOperatorElements());
	}
	
	public EnumRule getAdditionOperatorRule() {
		return getAdditionOperatorAccess().getRule();
	}

	//enum FactorOperator:
	//	mult="*" | division="/";
	public FactorOperatorElements getFactorOperatorAccess() {
		return (unknownRuleFactorOperator != null) ? unknownRuleFactorOperator : (unknownRuleFactorOperator = new FactorOperatorElements());
	}
	
	public EnumRule getFactorOperatorRule() {
		return getFactorOperatorAccess().getRule();
	}

	//enum ComparisonOperator:
	//	gt=">" | gte=">=" | lt="<" | lte="<=" | eq="==" | noteq="!=";
	public ComparisonOperatorElements getComparisonOperatorAccess() {
		return (unknownRuleComparisonOperator != null) ? unknownRuleComparisonOperator : (unknownRuleComparisonOperator = new ComparisonOperatorElements());
	}
	
	public EnumRule getComparisonOperatorRule() {
		return getComparisonOperatorAccess().getRule();
	}

	//enum UnaryLogicalOperator:
	//	not;
	public UnaryLogicalOperatorElements getUnaryLogicalOperatorAccess() {
		return (unknownRuleUnaryLogicalOperator != null) ? unknownRuleUnaryLogicalOperator : (unknownRuleUnaryLogicalOperator = new UnaryLogicalOperatorElements());
	}
	
	public EnumRule getUnaryLogicalOperatorRule() {
		return getUnaryLogicalOperatorAccess().getRule();
	}

	//enum BinaryLogicalOperator:
	//	and | or;
	public BinaryLogicalOperatorElements getBinaryLogicalOperatorAccess() {
		return (unknownRuleBinaryLogicalOperator != null) ? unknownRuleBinaryLogicalOperator : (unknownRuleBinaryLogicalOperator = new BinaryLogicalOperatorElements());
	}
	
	public EnumRule getBinaryLogicalOperatorRule() {
		return getBinaryLogicalOperatorAccess().getRule();
	}

	//enum TernaryOperator:
	//	ifExpression="if";
	public TernaryOperatorElements getTernaryOperatorAccess() {
		return (unknownRuleTernaryOperator != null) ? unknownRuleTernaryOperator : (unknownRuleTernaryOperator = new TernaryOperatorElements());
	}
	
	public EnumRule getTernaryOperatorRule() {
		return getTernaryOperatorAccess().getRule();
	}

	//enum BooleanValue:
	//	true | false;
	public BooleanValueElements getBooleanValueAccess() {
		return (unknownRuleBooleanValue != null) ? unknownRuleBooleanValue : (unknownRuleBooleanValue = new BooleanValueElements());
	}
	
	public EnumRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//Expression:
	//	FunctionDeclaration | VariableAssignment | LogicalBinaryExpression | LogicalUnaryExpression | TernaryExpression |
	//	ComparisonExpression | LetExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//LetExpression:
	//	"let" (assigment=VariableAssignment ",") expression=Expression;
	public LetExpressionElements getLetExpressionAccess() {
		return (pLetExpression != null) ? pLetExpression : (pLetExpression = new LetExpressionElements());
	}
	
	public ParserRule getLetExpressionRule() {
		return getLetExpressionAccess().getRule();
	}

	//TernaryExpression:
	//	operator=TernaryOperator "(" firstExpression=Expression "," secondExpression=Expression "," thirdExpression=Expression
	//	")";
	public TernaryExpressionElements getTernaryExpressionAccess() {
		return (pTernaryExpression != null) ? pTernaryExpression : (pTernaryExpression = new TernaryExpressionElements());
	}
	
	public ParserRule getTernaryExpressionRule() {
		return getTernaryExpressionAccess().getRule();
	}

	//LogicalBinaryExpression:
	//	operator=BinaryLogicalOperator "(" leftExpr=Expression "," rightExpr=Expression ")";
	public LogicalBinaryExpressionElements getLogicalBinaryExpressionAccess() {
		return (pLogicalBinaryExpression != null) ? pLogicalBinaryExpression : (pLogicalBinaryExpression = new LogicalBinaryExpressionElements());
	}
	
	public ParserRule getLogicalBinaryExpressionRule() {
		return getLogicalBinaryExpressionAccess().getRule();
	}

	//LogicalUnaryExpression:
	//	operator=UnaryLogicalOperator "(" expression=Expression ")";
	public LogicalUnaryExpressionElements getLogicalUnaryExpressionAccess() {
		return (pLogicalUnaryExpression != null) ? pLogicalUnaryExpression : (pLogicalUnaryExpression = new LogicalUnaryExpressionElements());
	}
	
	public ParserRule getLogicalUnaryExpressionRule() {
		return getLogicalUnaryExpressionAccess().getRule();
	}

	//ComparisonExpression returns Expression:
	//	NumericExpression ({ComparisonExpression.leftExpr=current} operator=ComparisonOperator rightExpr=NumericExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//FunctionDeclaration:
	//	"func" "(" (parameters+=ID ("," parameters+=ID)*)? ")" body=Body;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//Body:
	//	expressions+=Expression | {Body} "{" (expressions+=Expression ";")* "}";
	public BodyElements getBodyAccess() {
		return (pBody != null) ? pBody : (pBody = new BodyElements());
	}
	
	public ParserRule getBodyRule() {
		return getBodyAccess().getRule();
	}

	//SymbolReference:
	//	id=ID;
	public SymbolReferenceElements getSymbolReferenceAccess() {
		return (pSymbolReference != null) ? pSymbolReference : (pSymbolReference = new SymbolReferenceElements());
	}
	
	public ParserRule getSymbolReferenceRule() {
		return getSymbolReferenceAccess().getRule();
	}

	//NumericExpression returns Expression:
	//	Factor ({NumericExpression.leftFactor=current} operator=AdditionOperator rightFactor=Factor)*;
	public NumericExpressionElements getNumericExpressionAccess() {
		return (pNumericExpression != null) ? pNumericExpression : (pNumericExpression = new NumericExpressionElements());
	}
	
	public ParserRule getNumericExpressionRule() {
		return getNumericExpressionAccess().getRule();
	}

	//Factor returns Expression:
	//	Term ({Factor.leftTerm=current} operator=FactorOperator rightTerm=Term)*;
	public FactorElements getFactorAccess() {
		return (pFactor != null) ? pFactor : (pFactor = new FactorElements());
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}

	//Term returns Expression:
	//	LiteralExpression | Apply;
	public TermElements getTermAccess() {
		return (pTerm != null) ? pTerm : (pTerm = new TermElements());
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//Apply returns Expression:
	//	Functor ({Apply.functor=current} "(" (arguments+=Expression ("," arguments+=Expression)*)? ")")*;
	public ApplyElements getApplyAccess() {
		return (pApply != null) ? pApply : (pApply = new ApplyElements());
	}
	
	public ParserRule getApplyRule() {
		return getApplyAccess().getRule();
	}

	//Functor returns Expression:
	//	SymbolReference | ParenthesisExpression;
	public FunctorElements getFunctorAccess() {
		return (pFunctor != null) ? pFunctor : (pFunctor = new FunctorElements());
	}
	
	public ParserRule getFunctorRule() {
		return getFunctorAccess().getRule();
	}

	//LiteralExpression returns Expression:
	//	LiteralNumber | LiteralBoolean;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//LiteralBoolean:
	//	value=BooleanValue;
	public LiteralBooleanElements getLiteralBooleanAccess() {
		return (pLiteralBoolean != null) ? pLiteralBoolean : (pLiteralBoolean = new LiteralBooleanElements());
	}
	
	public ParserRule getLiteralBooleanRule() {
		return getLiteralBooleanAccess().getRule();
	}

	//LiteralNumber:
	//	value=INT;
	public LiteralNumberElements getLiteralNumberAccess() {
		return (pLiteralNumber != null) ? pLiteralNumber : (pLiteralNumber = new LiteralNumberElements());
	}
	
	public ParserRule getLiteralNumberRule() {
		return getLiteralNumberAccess().getRule();
	}

	//VariableAssignment:
	//	id=ID "=" expression=Expression;
	public VariableAssignmentElements getVariableAssignmentAccess() {
		return (pVariableAssignment != null) ? pVariableAssignment : (pVariableAssignment = new VariableAssignmentElements());
	}
	
	public ParserRule getVariableAssignmentRule() {
		return getVariableAssignmentAccess().getRule();
	}

	//ParenthesisExpression returns Expression:
	//	"(" Expression ")";
	public ParenthesisExpressionElements getParenthesisExpressionAccess() {
		return (pParenthesisExpression != null) ? pParenthesisExpression : (pParenthesisExpression = new ParenthesisExpressionElements());
	}
	
	public ParserRule getParenthesisExpressionRule() {
		return getParenthesisExpressionAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
